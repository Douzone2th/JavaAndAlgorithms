# JavaAndAlgorithms
 
## 4주차 문제(2/14 ~ 2/18)
2/14, 백준 알고리즘 : [2751번 수 정렬하기 2](https://www.acmicpc.net/problem/2751) </br>
2/15, 백준 알고리즘 : [10989번 수 정렬하기 3](https://www.acmicpc.net/problem/10989) </br>
2/16, 백준 알고리즘 : [5635번 생일](https://www.acmicpc.net/problem/5635) </br>
2/17, 백준 알고리즘 : [1755번 숫자놀이](https://www.acmicpc.net/problem/1755) </br>
2/18, 백준 알고리즘 : [2048번 n번째 큰 수](https://www.acmicpc.net/problem/2075) </br>
---
- ### 정렬 이란?
리스트나 배열과 같이 순서가 있는 항목을 데이터를 특정한 기준(오름차순, 내림차순)에 따라서 순서대로 나열하는 것이다.</br>
정렬을 해 놓으면 어떤 항목을 찾을 때, 이진 탐색 등과 같은 알고리즘을 이용해서 빠르고 편리하게 찾을 수 있다.</br>
---
- #### 정렬의 종류
```
1. Selection Sort(선택정렬) 
- 제자리 정렬 알고리즘.
- 자리는 정해져 있고 첫번째 자리에 가장 작은 자료를 집어 넣는 것 .
- 선택 정렬은 첫 번째 자료를 두 번째 자료부터 마지막 자료까지 차례대로 비교하여 가장 작은 값을 찾아 첫 번째에 놓고,
  두 번째 자료를 세 번째 자료부터 마지막 자료까지와 차례대로 비교하여 그 중 가장 작은 값을 찾아 두 번째 위치에 놓는 과정을 반복하며 정렬을 수행한다.
- 장점: 자료 이동 횟수가 미리 결정된다.
- 단점: 안정성을 보장하지 못한다. 값이 같은 레코드가 있는 경우에도 상대적인 위치가 변경 될 수 있다.
- 시간 복잡도 : O(n^2)
```
```
2.  Bubble Sort(버블정렬)
- 서로 인접한 두 원소를 검사하여 정렬하는 알고리즘
- 버블 정렬은 첫 번째 자료와 두 번째 자료를, 두 번째 자료와 세 번째 자료를, 세 번째와 네 번째를, … 이런 식으로 
  (마지막-1)번째 자료와 마지막 자료를 비교하여 교환하면서 자료를 정렬한다.
- 1회전을 수행하고 나면 가장 큰 자료가 맨 뒤로 이동한다.
- 회전하고 나서 고정된 자료를 제외 시키고 맨 뒤에서 맨 앞으로 정렬한다.
- 장점: 구현이 매우 간단하다.
- 단점: 순서에 맞지 않은 요소를 인접한 요소와 교환한다.
       하나의 요소가 가장 왼쪽에서 가장 오른쪽으로 이동하기 위해서는 배열에서 모든 다른 요소들과 교환되어야 한다.
- 시간복잡도 : O(n^2)
```
```
3. Insert Sort(삽입정렬) 
- 손안의 카드를 정렬하는 방법과 유사하다.
    + 새로운 카드를 기존의 정렬된 카드사이의 올바른 자리를 찾아 삽입한다.
    + 새로 삽입될 카드의 수만큼 반복하게 되면 전체 카드가 정렬된다.
- 자료 배열의 모든 요소를 앞에서부터 차례대로 이미 정렬된 배열 부분과 비교 하여, 자신의 위치를 찾아 삽입함으로써 정렬을 완성하는 알고리즘
- 즉, 두 번째 자료는 첫 번째 자료, 세 번째 자료는 두 번째와 첫 번째 자료, 네 번째 자료는 세 번째, 두 번째, 첫 번째 자료와 비교한 후 자료가 삽입될 위치를 찾는다. 
  자료가 삽입될 위치를 찾았다면 그 위치에 자료를 삽입하기 위해 자료를 한 칸씩 뒤로 이동시킨다.
- 즉, 두 번째 자료는 첫 번째 자료, 세 번째 자료는 두 번째와 첫 번째 자료, 네 번째 자료는 세 번째, 두 번째, 첫 번째 자료와 비교한 후 자료가 삽입될 위치를 찾는다. 자료가 삽입될 위치를 찾았다면 그 위치에 자료를 삽입하기 위해 자료를 한 칸씩 뒤로 이동시킨다.
- 장점: 안정된 정렬 방법
       레코드 수가 적을 경우 알고리즘 자체가 매우 간단하므로 다른 복잡한 정렬 방법보다 유리할 수 있다.
- 단점: 비교적 많은 레코드들의 이동을 포함한다.
       레코드 수가 많고 레코드의 크기가 클 경우에 적합 하지 않다.
- 시간복잡도 : 최선의 경우 O(n), 최악의 경우 O(n^2) 
```
```
4. Shell Sort (셀 정렬)
- 삽입정렬을 보완한 알고리즘.
- 삽입 정렬의 최대 문제점: 요소들이 삽입될 때, 이웃한 위치로만 이동.
- 즉, 만약 삽입되어야 할 위치가 현재 위치에서 상당히 멀리 떨어진 곳이라면 많은 이동을 해야 된다.
- 정렬해야 할 리스트의 각 k번째 요소를 추출해서 부분 리스트를 만든다.
- 정렬해야 할 리스트의 각 k번째 요소를 추출해서 부분 리스트를 만든다. 이때, k를 ‘간격(gap)’ 이라고 한다.
  + 간격의 초깃값: (정렬할 값의 수)/2
  + 생성된 부분 리스트의 개수는 gap과 같다.
- 각 회전마다 간격 k를 절반으로 줄인다. 즉, 각 회전이 반복될 때마다 하나의 부분 리스트에 속한 값들의 개수는 증가한다.
  + 간격은 홀수로 하는 것이 좋다.
  + 간격을 절반으로 줄일 때 짝수가 나오면 +1을 해서 홀수로 만든다.
- 간격 k가 1이 될 때까지 반복한다.
- 장점: 연속적이지 않은 부분 리스트에서 자료의 교환이 일어나면 더 큰 거리를 이동한다. 따라서 교환되는 요소들이 삽입 정렬보다는 최종 위치에 있을 가능성이 높아진다.
       부분 리스트는 어느 정도 정렬이 된 상태이기 때문에 부분 리스트의 개수가 1이 되게 되면 셸 정렬은 기본적으로 삽입 정렬을 수행하는 것이지만 삽입 정렬보다 더욱 빠르게 수행된다.
- 시간복잡도 : 최선의 경우 O(n), 평균의 경우 O(n^1.5), 최악의 경우 O(n^2) 
```
```
5. Quick Sort(퀵정렬) 
- 불안정 정렬, 다른 원소와의 비교만으로 정렬을 수행하는 비교 정렬
- 분할 정복 알고리즘, 평균적으로 매우 빠른 수행 속도
- 합병 정렬(merge sort)과 달리 퀵 정렬은 리스트를 비균등하게 분할
- 분할 정복(divide and conquer) 방법
  + 문제를 작은 2개의 문제로 분리하고 각각을 해결한 다음, 결과를 모아서 원래의 문제를 해결하는 전략이다.
  + 분할 정복 방법은 대개 순환 호출을 이용하여 구현한다.
- 과정설명 : 
  1. 리스트 안에 있는 한 요소를 선택한다. 이렇게 고른 원소를 피벗(pivot) 이라고 한다.
  2. 피벗을 기준으로 피벗보다 작은 요소들은 모두 피벗의 왼쪽으로 옮겨지고 피벗보다 큰 요소들은 모두 피벗의 오른쪽으로 옮겨진다. (피벗을 중심으로 왼쪽: 피벗보다 작은 요소들, 오른쪽: 피벗보다 큰 요소들)
  3. 피벗을 제외한 왼쪽 리스트와 오른쪽 리스트를 다시 정렬한다.
  + 분할된 부분 리스트에 대하여 순환 호출 을 이용하여 정렬을 반복한다.
  + 부분 리스트에서도 다시 피벗을 정하고 피벗을 기준으로 2개의 부분 리스트로 나누는 과정을 반복한다.
  4. 부분 리스트들이 더 이상 분할이 불가능할 때까지 반복한다.
  + 리스트의 크기가 0이나 1이 될 때까지 반복한다.
- 장점: 속도가 빠르다.
        + 시간 복잡도가 O(nlog₂n)를 가지는 다른 정렬 알고리즘과 비교했을 때도 가장 빠르다.
       추가 메모리 공간을 필요로 하지 않는다.
        + 퀵 정렬은 O(log n)만큼의 메모리를 필요로 한다.
- 단점: 정렬된 리스트에 대해서는 퀵 정렬의 불균형 분할에 의해 오히려 수행시간이 더 많이 걸린다.
        퀵 정렬의 불균형 분할을 방지하기 위하여 피벗을 선택할 때 더욱 리스트를 균등하게 분할할 수 있는 데이터를 선택한다.
        +  데이터 중에서 크기순으로 중간 값(medium)을 피벗으로 선택
- 시간복잡도 : 최선의 경우 O(nlog₂n), 최악의 경우 O(n^2) 
```
```
6. Counting Sort(계수정렬)
- 데이터의 값이 몇 번 나왔는지를 세주는 것이다. 말 그대로 counting 하는 것이다.
- 과정설명 :
  1. array[11] (0~10)
  2. array 를 한 번 순회하면서 각 값이 나올 때마다 해당 값을 index 로 하는 새로운 배열(counting[])의 값을 1 증가시킨다.
  3. 이런식으로 counting 배열은 각 값의 개수가 담겨있는 배열이 된다.
  4. counting 배열의 각 값을 누적합으로 변환시킨다. 
  5. 정렬을 할 경우 counting 배열의 각 값은 (시작점 - 1)을 알려준다는 것이다.
  6. counting 배열의 각 값은 (시작점 - 1)을 알려준다고 했다. 즉, 해당 값에 대응되는 위치에 배정하면 된다는 의미다. 
  7. 안정적으로 정렬하기 위해서는 array의 마지막 index 부터 순회하는 것이 좋다.
- 장점: 속도가 빠르다.엄청난 성능
- 단점:  counting 배열이라는 새로운 배열을 선언해주어야 한다는 점에서 메모리가 매우 낭비가 된다.
        예로들어 10개의 원소를 정렬하고자 하는데, 수의 범위가 0~1억이라면 메모리가 매우 낭비가 된다.
- 시간복잡도 : 평균의 경우 O(n+k), 최악의 경우 O(n+k)
- 
```
[카운팅 정렬 참고 사이트](https://st-lab.tistory.com/104)
```
7. Tim Sort(팀정렬)
- Merge Sort(합병 정렬), Insertion Sort(삽입 정렬)이 혼용 된 하이브리드 정렬
- 합병정렬을 기반으로 구현하되, 일정 크기 이하의 부분 리스트에 대해서는 이진 삽입 정렬을 수행하는 것이다.
-퀵 정렬(Quick Sort)처럼 빠른 속도의 정렬이나 병합 정렬처럼 항시 안정적인 O(NlogN)의 정렬 알고리즘들이 있음에도 
    이러한 두 가지 정렬 알고리즘을 혼용한 정렬들이 나온 것일까?
- 크게 정렬 알고리즘에서 성능을 미치는 원인은 크게 3가지로 볼 수 있다.
    1. 비교 및 스왑을 수행하기 위한 반복자(loop) = 반복자가 어떻게 구현되어있는가의 문제  --->시간복잡도로 측정
    2. 유효 접근 시간 (지역성)
    3. 메모리 소비량
- 목적: 현실 데이터들의 종류와 상관 없이 최적으로 정렬을 잘 수행하기 위해서 개발 된 방식이다.
-  Quick Sort의 경우 분명 일반적으로 빠르긴 하지만, 특정 상태(정렬 된 상태)에서는 급격히 성능이 떨어지게 된다. 
   Quick Sort의 경우 O(NlogN)의 같은 정렬 알고리즘 중에서도 매우 빠른 정렬 알고리즘이지만 재귀를 사용하기 때문에 
   매우 작은 리스트에서는 pivot을 기준으로 재귀적 호출을 하는 과정 자체가 추가적인 오버헤드가 발생하기 때문에 삽입정렬에서 리스트를 정렬하는 비용보다 더 커지기도 한다.
- 장점: 최상의 시간복잡도는 O(N)이다.
       객체 참조 및 비교 비용이 비싼 경우 Quick Sort에 비해 빠르다는 이점이 있다.
       안정정렬이 가능하다.
- 단점:  오버헤드가 O(NlogN) 알고리즘에 비해 큰 편이다.
        고도로 최적화 된 정렬 알고리즘인 만큼 구현 과정이 복잡하며 제대로 된 검증이 이루어지지 않을 경우 Bug가 발생할 여지가 높다.
- 시간복잡도 : 최악의 경우 O(nlog₂n),평균의 경우 O(nlog₂n) 최상의 경우 O(n)
```
```
8. 힙정렬 
- 최대 힙 트리나 최소 힙 트리를 구성해 정렬을 하는 방법
- 내림차순 정렬을 위해서는 최대 힙을 구성하고 오름차순 정렬을 위해서는 최소 힙을 구성하면 된다.
- 과정 설명
    - 정렬해야 할 n개의 요소들로 최대 힙(완전 이진 트리 형태)을 만든다.
    - 내림차순을 기준으로 정렬
    - 그 다음으로 한 번에 하나씩 요소를 힙에서 꺼내서 배열의 뒤부터 저장하면 된다.
    - 삭제되는 요소들(최댓값부터 삭제)은 값이 감소되는 순서로 정렬되게 된다.
- 최대 힙 삽입 
    - 힙에 새로운 요소가 들어오면, 일단 새로운 노드를 힙의 마지막 노드에 이어서 삽입한다.
    - 새로운 노드를 부모 노드들과 교환해서 힙의 성질을 만족시킨다.
- 장점 : 시간 복잡도가 좋은편
        힙 정렬이 가장 유용한 경우는 전체 자료를 정렬하는 것이 아니라 가장 큰 값 몇개만 필요할 때 이다.
- 시간복잡도 :  O(nlog₂n)
```
```
9. 합병정렬
- 일반적인 방법으로 구현했을 때 이 정렬은 안정 정렬 에 속하며, 분할 정복 알고리즘의 하나 이다.
- 분할 정복(divide and conquer) 방법
- 문제를 작은 2개의 문제로 분리하고 각각을 해결한 다음, 결과를 모아서 원래의 문제를 해결하는 전략이다.
- 분할 정복 방법은 대개 순환 호출을 이용하여 구현한다.
- 과정 설명
    - 리스트의 길이가 0 또는 1이면 이미 정렬된 것으로 본다. 그렇지 않은 경우에는
    - 정렬되지 않은 리스트를 절반으로 잘라 비슷한 크기의 두 부분 리스트로 나눈다.
    - 각 부분 리스트를 재귀적으로 합병 정렬을 이용해 정렬한다.
    - 두 부분 리스트를 다시 하나의 정렬된 리스트로 합병한다.
- 단계
    - 합병 정렬은 다음의 단계들로 이루어진다.
    - 분할(Divide): 입력 배열을 같은 크기의 2개의 부분 배열로 분할한다.
    - 정복(Conquer): 부분 배열을 정렬한다. 부분 배열의 크기가 충분히 작지 않으면 순환 호출 을 이용하여 다시 분할 정복 방법을 적용한다.
    - 결합(Combine): 정렬된 부분 배열들을 하나의 배열에 합병한다.
- 장점 :
    - 안정적인 정렬 방법
    - 데이터의 분포에 영향을 덜 받는다. 즉, 입력 데이터가 무엇이든 간에 정렬되는 시간은 동일하다. (O(nlog₂n)로 동일)
    - 만약 레코드를 연결 리스트(Linked List)로 구성하면, 링크 인덱스만 변경되므로 데이터의 이동은 무시할 수 있을 정도로 작아진다.
    - 제자리 정렬(in-place sorting)로 구현할 수 있다.
    - 따라서 크기가 큰 레코드를 정렬할 경우에 연결 리스트를 사용한다면, 합병 정렬은 퀵 정렬을 포함한 다른 어떤 졍렬 방법보다 효율적이다.
- 단점 :
    - 만약 레코드를 배열(Array)로 구성하면, 임시 배열이 필요하다.
    - 제자리 정렬(in-place sorting)이 아니다.
    - 레크드들의 크기가 큰 경우에는 이동 횟수가 많으므로 매우 큰 시간적 낭비를 초래한다
- 시간복잡도 : 순환 호출의 깊이 만큼의 합병 단계 * 각 합병 단계의 비교 연산 = nlog₂n
```
```
10. 이진 삽입 정렬
- 배열에서 인덱스 i를 증가시키며 왼쪽의 정렬된 곳에 
  array[i]가 들어갈 위치를 찾아서 삽입하는 방식의 정렬인 삽입정렬에서 array array[i]가 들어갈 위치를 이진 검색(Binary Search)을 이용해 찾는 정렬
- 장점 :
    -  추가적인 메모리 소비가 작다.
    - 비교 비용이 비싸질 수록 삽입 정렬에 비해 빨라진다.
    - 안장정렬이 가능하다.
    - 추가 구현을 통해 최상의 경우 O(N)의 시간복잡도를 갖게 된다.
- 단점 :
    - 항상 삽입정렬보다 빠른 것은 아니다.
    - 평균 시간 복잡도는 삽입정렬과 동일하게 O(N2) 이다.
- 시간복잡도: 최악의 경우 O(n^2),최상의 경우 O(NlogN)
```
[정렬 알고리즘 참고 사이트](https://gmlwjd9405.github.io/tags#algorithm)
---
