# JavaAndAlgorithms

## 6주차 문제(2/28 ~ 3/4)
2/28, 백준 알고리즘 : [2309번 일곱 난쟁이](https://www.acmicpc.net/problem/2309) </br>
3/1, 백준 알고리즘 : [7568번 덩치](https://www.acmicpc.net/problem/7568) </br>
3/2, 백준 알고리즘 : [1120번 문자열](https://www.acmicpc.net/problem/1120) </br>
3/3, 백준 알고리즘 : [1476번 날짜계산](https://www.acmicpc.net/problem/1476) </br>
3/4, 백준 알고리즘 : [9663번 N-Queen](https://www.acmicpc.net/problem/9663) </br>
---

### 완전 탐색(브루트 포스)이란?
- '무식하게 푼다'라는 의미인 Brute-Force (브루트 포스)
- 당연히 가능한 모든 경우의 수들을 다 구해서 그중에 만족 하는 답을 찾아 내는 것
- 완전 탐색 기법 고려할점
    1) 해결하고자 하는 문제의 가능한 경우의 수를 대략적으로 계산한다.
    2) 가능한 모든 방법을 다 고려한다.
    3) 실제 답을 구할 수 있는지 적용한다.
- 완전 탐색 기법
    - 단순 Brute-Force
    - 백트래킹
    - 비트마스크(Bitmask)
    - 재귀 함수
    - 순열 (Permutation)
    - BFS / DFS
---
- 단순 Brute-Force
```
어느 기법을 사용하지 않고 단순히 for문과 if문 등으로 모든 case들을 만들어 답을 구하는 방법이다. 
이는 아주 기초적인 문제에서 주로 이용되거나, 전체 풀이의 일부분으로 이용한다.
예를 들어, 4자리로 된 번호 자물쇠를 푼다고 할 때 최악의 경우(0000 ~ 9999까지 모두 시도) 10000 * 1초 = 대략 166분 (컴퓨터의 연산 속도 : 대략 1초에 1억) 이 걸릴 수 있다.

```
---
- 백트래킹
```
현재 상태에서 가능한 후보군으로 가지를 치며 탐색하는 알고리즘이다. 분할정복을 이용한 기법으로, 
재귀함수를 이용하고 해를 찾아가는 도중 해가 될 것 같지 않은 경로가 있다면 더 이상 가지 않고 되돌아간다.

- 분할 정복법
    - 주어진 문제를 작은 사례로 나누고(Divide) 각각의 작은 문제들을 해결하여 정복 (Conquer)하는 방법이다.
    - 문제의 사례를 2개 이상의 더 작은 사례로 나눈다. 이 작은 사례는 주로 원래 문제에서 따온다. 
    - 나눈 작은 사례의 해답을 바로 얻을 수 있으면 해를 구하고 아니면  더 작은 사례로 나눈다. 해를 구할 수 있을 만큼 충분히 더 작은 사례로 나누어 해결하는 방법
    - 분할정복법의 설계전략
        1. 문제 사례를 하나 이상의 작은 사례로 분할(Divide)한다.
        2. 작은 사례들을 각각 정복(Conquer)한다. 작은 사례가 충분히 작지 않은 이상 재귀를 사용한다.
        3. 필요하다면, 작은 사례에 대한 해답을 통합(Combine)하여 원래 사례의 해답을 구한다.
```
---
- 비트마스크(Bitmask)
```
비트 마스크 (Bit Mask)는 2진수를 이용하는 컴퓨터의 연산을 이용하는 방식이다. 
완전 탐색에서 비트마스크는 문제에서 나올 수 있는 모든 경우의 수가 각각의 원소가 포함되거나, 
포함되지 않는 두 가지 선택으로 구성되는 경우에 유용하게 사용 가능하다.
예를 들어, 원소가 5개인 집합의 모든 부분집합을 구하는 경우를 생각해보면, 
어떤 집합의 부분집합은 집합의 각 원소가 해당 부분집합에 포함되거나 포함되지 않는 두 가지 경우만 존재한다. 
따라서 5자리 이진수를 이용하여 각 원소의 포함 여부를 체크할 수 있다.

비트 연산이란 다음과 같은 것들이 있다.

And 연산(&) : 둘 다 1이면 1
OR 연산(|) : 둘 중 1개만 1이면 1
NOT 연산(~) : 1이면 0, 0이면 1
XOR 연산(^) : 둘의 관계가 다르면 1, 같으면 0
Shift 연산(<<, >>) : A << B라고 한다면 A를 좌측으로 B 비트만큼 미는 것이다.
```
---
- 재귀 함수
```
재귀함수를 통해서 문제를 만족하는 경우들을 만들어가는 방식이다.
예를 들어, 총 4개의 숫자 중에 2개를 선택하는 경우를 모두 출력한다고 가정해보자. 1~4까지 숫자가 있고 2개를 중복 없이 선택하는 모든 경우의 수를 출력하고자 한다고 가정하자.
손 쉽게 2중 반복문으로 해결하였다. 그런데.. 만약 숫자 N개의 숫자 중 M개를 고르는 경우라고 할 때, N과 M이 매우 큰 숫자라면 어떨까? 
반복문을 수백, 수천 개를 써 내려갈 수는 없다!

재귀 함수를 활용한다면 자기 자신을 호출함으로써 다음 숫자를 선택할 수 있도록 이동시켜 전체 코드를 매우 짧게 줄일 수 있다!
```
##### - 중요한점   
```
⑴ 재귀를 탈출하기 위한 탈출 조건이 필요!
  ▶ 이것이 없으면 n개를 모두 골랐음에도 더 숫자를 선택하고자 하여 선택된 숫자를 저장하는 배열에 범위 초과 오류가 나거나, 다른 자료구조를 쓴 경우 잘못된 출력이 나올 수 있고, 혹은 무한 루프가 발생할 수 있다!

⑵ 현재 함수의 상태를 저장하는 Parameter가 필요!
  ▶ 위에서 우리는 curr, cnt를 통해 어떤 숫자까지 선택했는지, 몇 개를 선택했는지 전달하였다. 이것이 없다면 현재 함수의 상태를 저장할 수 없어 재귀 탈출 조건을 만들 수 없게 되거나 잘못된 결과를 출력하게 된다!

⑶ Return문을 신경 쓸 것!
  ▶ 위의 함수는 단순 출력이기에 void로 함수를 작성했다. 그런데, 재귀를 통해 이후의 연산 결과를 반환 후 이전 결과에 추가 연산을 수행하는 경우도 있을 수 있다. 즉, 문제 해결을 위한 정확한 정의를 수행하여야 이것을 완벽히 풀 수 있다.
```
---
- 순열
```
순열은 임의의 수열이 주어졌을 때 그것을 다른 순서로 연산하는 방법이다.
서로 다른 N개를 일렬로 나열하는 순열의 경우의 수는 N!이므로 완전 탐색을 이용하기 위해서는 N이 한자리 수 정도는 되어야 한다.

즉, 순서가 중요함! 만약, 수열에서 숫자 [1, 2, 3]이 있다면, 이것을 [1, 2, 3]으로 보는 순서와 [3, 2, 1]로 보는 순서가 차이가 있음이 중요한 경우를 의미한다.
같은 데이터가 입력된 수열이지만, 그 순서에 따라 의미가 있고 이 순서를 통해 연결되는 이전 / 다음 수열을 찾아낼 수 있는 경우를 계산할 수 있다.

위 내용과 같이 순열을 나열할 수 있는데, 최초 / 최종 순열을 보면 숫자가 오름 / 내림차순인 것을 알 수 있다. (중복된 숫자가 있다면 비내림 / 비오름차순으로 된다.)

여기서 사전 순 순열의 규칙을 알아낼 수 있는데 N개의 데이터가 있고 1~i번째 데이터를 설정했을 때, i번째 데이터 기준 최종 순열은 i+1부터 N까지가 모두 내림차순이라는 것이다.(반대로 최초 순열이면 i+1부터 N이 오름차순!)

예를 들어, 1 3 2를 보자. 이는 0번째 숫자가 1일 때의 최종 순열이다. 왜냐하면 3 2는 내림차순이기 때문이다. 그렇다면 이 다음 순열은 어떻게 구할 수 있을까?

i번째가 고정이었고 i+1부터 내림차순인 경우가 최종 순열이므로 다음은 i번째부터 모두 오름차순이 되는 최초 순열이 된다. 즉, i-1까지는 변동이 없고 i는 i+1 ~ N까지의 숫자 중 자신보다 크지만 가장 작은 숫자와 교환이 되고 그 i+1~N은 다시 오름차순이 되어야 한다.

그래서 1 3 2의 다음 순열은 2 1 3이다. 1 3 2에서 1은 2와 교체되었고 1 3은 오름차순으로 정렬되었다.
```
```
※ 순열을 구현하는 방법

현재 순열을 구성하는 배열을 A라고 하고 i,j는 그 배열의 index 값을 의미한다고 하자. 예를 들어 A={7, 2, 3, 6, 5, 4, 1}이고 i, j는 각각의 index 값이다.

아래에서는 현재의 다음 순열을 구하는 로직을 기반으로 설명한다.

1. A[i-1] <= A[i]를 만족하는 i 중 가장 큰 값을 찾는다.(혹은 뒤에서부터 찾는 경우 A[i-1] >= A[i] 중 가장 작은 i를 찾는다.)
  → 현재 i값을 기준으로 이후는 모두 내림차순으로 되는 경우를 찾는 다는 것이다. 현재 기준 최종 순열을 찾음
      A배열을 보면 A[i-1] < A[i]가 되는 가장 큰 i는 6인 3번째(0부터 시작)이다. 즉, i=3이 된다.

2. j >= i 중, A[j] > A[i-1]을 만족하는 가장 큰 j의 값을 찾는다.
  → 현재가 최종 순열 상태이므로 i-1번째 숫자를 변경하여 최초 순열을 찾아야 한다.
      A배열을 기준으로 i-1번째 숫자는 3으로 3보다 큰 경우는 6, 5, 4이나 그 중 j 값이 가장 큰 경우는 4이다.

3. A[i-1]과 A[j]를 Swap한다.
   → i-1인 2번째 숫자 3과 j인 5번째 숫자 4를 변경한다. A 배열은 다음과 같이 변경된다.
      A={7, 2, 4, 6, 5, 3, 1}

4. i이후의 순열을 모두 뒤집는다.
   → 최초 순열 상태로 만들어야 하므로 i번째부터는 오름차순으로 만들어야 한다. A 배열은 다음과 같이 변경된다.
      A={7, 2, 4, 1, 3, 5, 6}
```
---
- BFS/DFS
```

```
